package JuegoVida;

import java.util.*;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//Creamos arraylist de Tripleta.
		ArrayList <Tripleta> datos = new ArrayList <Tripleta>();
		//preguntamos filas y columnas y las generaciones, con el método para que sea válido.
		int filas = comprobarEntrada("filas");
		int columnas = comprobarEntrada("columnas");
		int numGeneraciones = comprobarEntrada("generaciones");
		//Crear tablero donde se irán almacenando.
		String [][] tablero = new String[filas][columnas];      //Si introduce fila 0 y columna 0 da ERROR.			
		//rellenar tablero con células aleatoriamente.
		rellenar(tablero);
		//Empieza el desarrollo del programa.
		int veces = 0; //Variable para controlar las veces que tiene que realizar el bucle
		int celActual = 0; // Variable para almacenar el conteo de celdas que están vivas.
		//Realiza el bucle hasta que llegue a la generación indicada
		while(veces <= numGeneraciones) {
			celActual = contarCel(tablero); //Resgistra el conteo de células
			Tripleta celda = new Tripleta(); //Genera un objeto de tipo Tripleta para llenarlo con la info.
			//Ir rellenando la tripleta
			if(veces == 0) { 
				//Caso inicial de generación 0. Las células Nuevas también serán las actuales. 
				celda.setNumCelVivas(celActual); 
				celda.setNumCelNuevas(celActual);
				datos.add(celda); //Se añade el objeto al ArrayList
			}
			else { 
				//Resto de casos para las demás generaciones
				celda.setNumCelVivas(celActual);
				celda.setNumCelNuevas(celActual - (datos.get(datos.size()-1).getNumCelVivas())); //(Celulas actuales) - (celulas gen. Anterior.)
				datos.add(celda);  //Se añade el objeto al ArrayList
			}
			//Imprimir información por pantalla
			System.out.println("GENERACIÓN: " + veces);
			//Código debbuger
//			System.out.println("HAY UN TOTAL DE: " + datos.get(veces).getNumCelVivas() + " CELULAS VIVAS");
//			if(veces > 0) {
//				System.out.println("VIVAS RESPECTO A LA ANTERIOR GENERACIÓN: " + datos.get(veces).getNumCelNuevas());
//			}
			//Visualizar el tablero
			visualizar(tablero);
			System.out.println();
			//Aplica el método principal de creación de células 
			supervivencia(tablero);																//CAMBIAR WORD
			if(celActual == 0) { //Si No hay celulas vivas, se extingue la colonia
				System.out.println("COLONIA EXTINGUIDA");
				break;
			}
			veces++; //Suma el contador de los procesos.
		}
		//Si ha llegado al máximo de generaciones, dice cuantas quedan vivas.
		if(veces == numGeneraciones + 1) {
			System.out.println("Quedan " + celActual + " vivas.");
		}
		//Por último, muestra por pantalla la información del ArrayList.
		System.out.println();
		System.out.println("----------------------------RESUMEN-------------------------------");
		System.out.printf("%-15s %-20s %-15s %n", "Generación", "Celulas vivas", "Celulas respecto al anterior");
		System.out.println("------------------------------------------------------------------");
		for (Tripleta i:datos) {
			System.out.printf("%-3d| %20d| %20s%-3d| %n", i.getGeneracion(), i.getNumCelVivas(), (i.getNumCelNuevas() > 0 ? "+" : "-"), i.getNumCelNuevas()*(-1));
		}
		
//		resultado += "El resultado de " + num1 + " * " + num2 + " = " + (num1 * num2) + " ----- " + ((num1 * num2) == respuesta ? "Acierto" : "Fallo") + "\n";
//		contOperacion++;
		
		
	}
	
	
	
	
	
	/**
	 * Método para hacer más robusto el programa en caso de que el usuario introduzca un valor no posible.
	 * @param String que contiene parte de la pregunta.
	 * @return devuelve como válido un número entero mayor de 0.
	 */
	public static int comprobarEntrada(String pregunta) {
		int num = 0;
		boolean correcto = false; //variable para controlar que sea válido o no el número
		do {
			try { //Hace un try y recoge el Catch el error,
				Scanner entrada = new Scanner (System.in);
				System.out.println("Introduce el número de " + pregunta);
				num = entrada.nextInt();
				if(num < 0) {
					System.out.println("error");
					correcto = false;
				}
				else{ //si es correcto pasa a ser true y finaliza el bucle while y llega al return final.
					correcto = true;
				}
			}catch (InputMismatchException e) {
				System.out.println("error");
				correcto = false;
			}
		}while(!correcto); //Mientras no sea correcto no dejará de pedir el dato al usuario.
		return num;
	}
	
	
	/**
	 * Método para visualizar el tablero.
	 * @param tablero
	 */
	public static void visualizar(String[][] tabla) {
		for (int i = 0; i < tabla.length; i++) {
			System.out.print("|");
			for(int j = 0; j < tabla[i].length; j++) {
				System.out.print(tabla[i][j]+"|");
			}
			System.out.println();
		}
	}
	
	/**
	 * Método para rellenar aleatoriamente el tablero de células.
	 * @param tablero
	 */
	public static void rellenar(String [][] tabla) {
		//Recorre la tabla y la llenará aleatoriamente.
		int random; //variable para almacenar el random
		for (int i = 0; i < tabla.length; i++) {
			for(int j = 0; j < tabla[i].length; j++) {
				random =  (int) (Math.random() * 10); //Se irá cambiando con una cifra del 0 - 9
				//System.out.println(random); //Código debuggear
				if(random <= 1 ) {
					tabla[i][j] = "*"; //Si es 20% añadirá una célula
				}
				else {
					tabla[i][j] = " "; //El restante corresponde al 80% y crea un sitio vacío.
				}
			}
		}
	}
	
	/**
	 * Método que cuenta las celulas vivas en ese momento.
	 * @param tabla
	 * @return integer con el conteo
	 */
	public static int contarCel(String [][] tabla) {
		int contador = 0; //variable para ir haciendo el conteo.
		for (int i = 0; i < tabla.length; i++) {
			for(int j = 0; j < tabla[i].length; j++) {
				//Si encuentra una viva la cuenta, si no pasa a la siguiente celda
				if(tabla[i][j].equals("*")) { 
					contador++;
				}
			}
		}
		return contador;
	}
	
	/**
	 * Método para realizar el proceso de la supervivencia o no de una celda.
	 * @param Recibe el tablero completo
	 */
	public static void supervivencia(String [][] tabla) {
		boolean estado = false; //Variable para registrar si esta viva o muerta.
		int count = 0; //Contador de celulas de alrededor.
		//Tabla Auxiliar donde se irán recogiendo los resultados para no ir sobreescibiendo la principal.
		String [][] tablaAux = new String[tabla.length][tabla[0].length];
		for (int i = 0; i < tabla.length; i++) {
			for(int j = 0; j < tabla[i].length; j++) {
				//Para cada celda primero registra si existe una célula o no.
				if(tabla[i][j].equals("*")) {
					estado = true;
					count--; //Le resta uno al contador ya que en la comprobación posterior el bucle haráse contará a ella misma.
				}
				else {
					estado = false;
				}
				//A continuación recorre alrededor buscando las celulas vivas.
				for (int fila = i - 1; fila < i + 2; fila++) {
					for (int columna = j - 1; columna < j + 2; columna++) {
						//Gracias a ese método se evita que llegue a buscar en una posición que está fuera de los límites.
						if (validacionCelda(tabla, fila, columna)) {
							if (tabla[fila][columna].equals("*")) {
								count++;
							}	
						}
					}
				}
				//Ya con el conteo y el estado de la celda, aplica las reglas del juego:
			    //Si está muerta y tiene 3 vivas alrededor revivirá.
				if (!estado && count == 3) {
					//RESUCITAR.
					tablaAux[i][j] = "*";
				}
				//si está viva y tiene 2 o 3 vivas sigue viva,
				else if(estado && (count == 2 || count == 3)){
					//SOBREVIVE.
					tablaAux[i][j] = "*";
				}
				//de lo contrario en todos los otros casos muere.
				else {
					//ESTARÁ MUERTA.
					tablaAux[i][j] = " ";
				}
				count = 0; //vuelve a restaurar el contador para la siguiente celda recorrida del bucle.
			}
		}
		//Una vez que ha recorrido todo el tablero,
		//Se copia la tabla AUX en la tabla PRINCIPAL para el cambio de generación.
		for (int i = 0; i < tabla.length; i++) {
			for(int j = 0; j < tabla[i].length; j++) {
				tabla[i][j] = tablaAux[i][j];
			}
		}
	}
	
	/**
	 * Método para comprobar que las posiciones del tablero no estén fuera de los límites.
	 * @param recibe el tablero para saber las dimensiones
	 * @param i corresponde a la coordenada X
	 * @param j coresponde a la coordenada Y
	 * @return devuelve TRUE en caso de que no esté fuera de los límites
	 */
	public static boolean validacionCelda(String[][] tabla, int i, int j) {
		//Si encuentra una coordenada menor de 0 o mayor que los límites de la tabla, devuelve FALSE.
		if(i < 0 || i >= tabla.length || j >= tabla[0].length || j < 0) {
			return false;
		}
		else {
			return true;
		}
	}

}
